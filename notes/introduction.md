# Introduction

- This course will explore two broad areas:

  1) Computational Theory

     >  What are the fundamental capabilities and limitations of computers?

  2) Computational Practice

     > How to solve problems using industry-standard approaches?

- Balancing act between the two areas

  ![Photograph of Philippe Petit walking tightrope between Twin Towers](media/1872.jpg)

  â€‹             (https://www.theguardian.com/artanddesign/2015/nov/20/philippe-petit-twin-towers-tightrope)

  - Strategies: 
    1. Draw problems for practice from the theory
       - e.g. arithmetic expression interpreter
    2. Focus on practical applications that emerge from theory
       - e.g. regular expression matching

## Theory

1. **Automata and Formal Languages**
   1. What is a computer?
   2. What is a computational problem?
2. **Computability**
   1. What kinds of computational problems are solvable and what kinds are impossible to solve
3. **Complexity**
   1. What kinds of solvable problems are tractable and what kinds are intractable?

Approach: emphasis on conclusions and their relevance, not on proofs and mathematical rigor

Useful background:
- Understanding of basic datastructures and algorithms (sorting, stacks, queues, graphs, etc.)
- Some mathematical background in sets, sequences, tuples, functions, relations, graphs, strings, boolean logic, proofs, etc.

If you're missing some of the background above, no worries, I'll cover them as needed and provide extra help as needed

## Practice

**Industry-standard approaches**
1. Collaboration
   1. Version control
   2. Parallelized development
   3. Performance and memory management
      1. Algorithms and datastructure choices
2. Terminal/commandline
3. Using generative AI to develop a program

Approach:
- Programming assignments (both individual and group) 
- In-class exercises
- "Tales from the trenches"

## Conclusions (sneak peek)

1. **Universality**: all computers are equivalent in capabilities to a simple abstract machine called a Turing Machine
2. **Computability**: there exist useful problems that no computer can solve, ever
3. **Complexity**: there exist useful problems that are solvable but we don't know of a tractable solution yet, and aren't sure whether a tractable solution is possible
